%YAML 1.2
---
meta:
  title: Web security
  desciption: The web and application development process is in par with the current security best practices.
  background:
    Ultimately any Internet facing service must accept user input over the Internet. If the application is not written following the best practices, it's trivial to conduct an attack exploiting the application vulnerabilities.

    This section does not discuss the web application vulnerabilities and mitigating them in detail. Instead, the team should use proper well-known secure framework in their application development, as usually the framework authors are well-versed in security matters and have thought out and documented the proper security matters.

questions:
  A framework preventing database injection attacks:
    question: The software is written in a manner that there is no possibility of database injection attack
    rationale: One of the most common web application vulnerabilities is a database injection attack. In the most cases, the database is SQL based, providing opportunity for SQL injections. This can be easily prevented by never constructing database statements by hand and always using a framework to construct the queries, so that all values are properly escaped. The manual SQL manipulation should be prevented from the application developers, so that no room is left for a human error.
    answers: default
    applies: everyone
    links:
      - SQL injection in Wikipedia, https://en.wikipedia.org/wiki/SQL_injection
      - SQL injection in OWASP, https://www.owasp.org/index.php/SQL_Injection
      - PCI DSS, v3.1, requirement 6.5.1, https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-1.pdf

  A framework preventing cross-site scripting attacks:
    question: The software is written in a manner that there is no possibility of cross-site scripting attack
    rationale: Cross-site scripting attack is a way to perform actions on the behalf of the user when the user views or clicks a compromised payload. The attack target can be the site visitor or the site administrator. The usual cross-site scripting attack is posting text or file attachment which payload is not well-escaped HTML. This attack can be avoided by using a proper software development framework which always escapes variables in output and not relying the developers to manually escape variables in page templates, JavaScript or HTML JSON embeds.
    applies: everyone
    links:
      - Cross site scripting in Wikipedia, https://en.wikipedia.org/wiki/Cross-site_scripting
      - Cross site scripting in OWASP, https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29
      - Handling untrusted JSON safely in WhiteHat Security, https://blog.whitehatsec.com/handling-untrusted-json-safely/

  Password storage best practices:
    question: The user passwords and two-factor seed tokens are hashed using the state-of-the-art encryption
    rationale: This protects the user password integrity in the case the database is compromised. The developers should not do password management themselves, but use a proper framework or a library for it.
    applies: everyone
    links:
      - PBKDF2 (Password-Based Key Derivation Function 2) in Wikipedia, https://en.wikipedia.org/wiki/PBKDF2
      - Password storage cheat sheet in OWASP, https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet

  Non-guessable administration site:
    question: The administration site URLs cannot be guessed
    rationale: Many common software platforms come with the default administration site location like */admin/*. If these URLs are well-known the attacker can exploit this and guess weak administration interface HTTP endpoints to exploit those. An easy solution is to move the administration interface to a non-guessable, non-end user visible, URL.
    links:
      - Failure to restrict URL Access in OWASP, https://www.owasp.org/index.php/Top_10_2010-A8-Failure_to_Restrict_URL_Access


